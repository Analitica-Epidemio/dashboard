# Aplicacion (Frontend, API, Celery)
# Blue/Green deployment - este compose se usa con -p ${APP_NAME}_blue o -p ${APP_NAME}_green
#
# DB y Redis estan en compose.infra.yaml (compartidos entre blue/green)
#
# Uso:
#   make deploy          # Deploy blue-green automatico
#   make deploy-setup    # Setup inicial

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        NEXT_PUBLIC_API_HOST: ${NEXT_PUBLIC_API_HOST}
        NEXT_PUBLIC_APP_ENV: production
        SECRET_KEY: ${SECRET_KEY}
        NEXTAUTH_SECRET: ${NEXTAUTH_SECRET:-${SECRET_KEY}}
        NEXTAUTH_URL: ${NEXTAUTH_URL:-${FRONTEND_URL}}
    image: ${APP_NAME:-epidemiologia}-frontend:${ENV_COLOR:-prod}
    ports:
      - "127.0.0.1:${FRONTEND_PORT:-3000}:3000"
    environment:
      NEXT_PUBLIC_API_HOST: ${NEXT_PUBLIC_API_HOST}
      NEXT_PUBLIC_APP_ENV: production
      SECRET_KEY: ${SECRET_KEY}
      NEXTAUTH_SECRET: ${NEXTAUTH_SECRET:-${SECRET_KEY}}
      NEXTAUTH_URL: ${NEXTAUTH_URL:-${FRONTEND_URL}}
      NODE_ENV: production
      # URL interna para llamadas server-side (NextAuth -> API)
      # Usa nombre explicito para evitar ambiguedad en blue-green deployment
      API_HOST_INTERNAL: http://${APP_NAME:-epidemiologia}_${ENV_COLOR:-prod}_api:8000
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "node", "-e", "fetch('http://localhost:3000').then(r => process.exit(r.ok ? 0 : 1)).catch(() => process.exit(1))"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  api:
    build:
      context: ./backend
      dockerfile: Dockerfile
    image: ${APP_NAME:-epidemiologia}-api:${ENV_COLOR:-prod}
    container_name: ${APP_NAME:-epidemiologia}_${ENV_COLOR:-prod}_api
    ports:
      - "127.0.0.1:${API_PORT:-8000}:8000"
    environment:
      ENVIRONMENT: production
      DATABASE_URL: postgresql+asyncpg://${DB_USER}:${DB_PASSWORD}@${APP_NAME:-epidemiologia}_postgres:5432/${DB_NAME}
      REDIS_URL: redis://${APP_NAME:-epidemiologia}_redis:6379/0
      CELERY_BROKER_URL: redis://${APP_NAME:-epidemiologia}_redis:6379/0
      CELERY_RESULT_BACKEND: redis://${APP_NAME:-epidemiologia}_redis:6379/0
      SECRET_KEY: ${SECRET_KEY}
      CORS_ORIGINS: ${CORS_ORIGINS}
      ALLOWED_HOSTS: ${ALLOWED_HOSTS}
      FRONTEND_URL: ${FRONTEND_URL}
    volumes:
      - uploads:/app/uploads
      - logs:/app/logs
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000/health')"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s

  celery_worker:
    image: ${APP_NAME:-epidemiologia}-api:${ENV_COLOR:-prod}
    environment:
      ENVIRONMENT: production
      DATABASE_URL: postgresql+asyncpg://${DB_USER}:${DB_PASSWORD}@${APP_NAME:-epidemiologia}_postgres:5432/${DB_NAME}
      REDIS_URL: redis://${APP_NAME:-epidemiologia}_redis:6379/0
      CELERY_BROKER_URL: redis://${APP_NAME:-epidemiologia}_redis:6379/0
      CELERY_RESULT_BACKEND: redis://${APP_NAME:-epidemiologia}_redis:6379/0
      SECRET_KEY: ${SECRET_KEY}
    volumes:
      - uploads:/app/uploads
      - logs:/app/logs
    restart: unless-stopped
    command: ["celery", "-A", "app.core.celery_app:celery_app", "worker", "--loglevel=warning", "--concurrency=4", "--queues=default,file_processing,geocoding,maintenance"]

volumes:
  uploads:
  logs:

networks:
  default:
    name: ${APP_NAME:-epidemiologia}_network
    external: true
